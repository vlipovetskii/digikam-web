package vlite.digikamweb.backend.base.storage

import org.slf4j.Logger
import org.springframework.util.FileSystemUtils
import java.nio.file.CopyOption
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.StandardCopyOption
import kotlin.io.path.*

interface BaseFileStorageA {

    val directoryExists: Boolean

    fun logErrorIfNotExists(log: Logger)

    fun editAccessCodeFromFile(log: Logger?) : String?
    fun editAccessCodeToFile(editAccessCode: String)

    companion object {
        /**
         * Since Vaadin route templates use [java.util.regex.Pattern], let's use java regex.
         *
         * [A Guide To Java Regular Expressions API](https://www.baeldung.com/regular-expressions-java)
         *
         * Generated by ChatGPT for java:
         * ```
         * ^ → Ensures the match starts at the beginning.
         * [a-zA-Z0-9\\-]+ → Ensures the rest of the string consists one or more only of:
         *      Latin letters (a-zA-Z)
         *      Digits (0-9)
         *      Hyphens (-)
         * $ → Ensures the entire string follows this pattern (no extra characters)
         * ```
         *
         * Valid linux file name MUST not contain / and \0.
         *
         * [Reserved characters](https://en.wikipedia.org/wiki/Percent-encoding#Reserved_characters)
         * Reserved characters after percent-encoding
         * '/' -> %2F
         */
        const val NAME_VALID_REGEX = "^[^%2F\\x00]+$"
    }

    interface Implementation : BaseFileStorageA, EditAccessCodeFileA.Implementation {

        val homePath: Path

        override val directoryExists get() = homePath.exists()

        override val editAccessCodeDirectoryPath get() = homePath

        fun ByteArray.writeTo(path: Path, fileNameWithExtension: String) : Path {
            val filePath: Path = path.resolve(fileNameWithExtension)
            filePath.outputStream().use {
                it.write(this)
            }
            return filePath
        }

        /**
         * [Java – Rename or Move a File](https://www.baeldung.com/java-how-to-rename-or-move-a-file)
         * ```
         * 3. Using the NIO Paths and Files Classes
         *      Let’s start by using the Files.move() method from the Java NIO package:
         * ```
         */
        fun Path.rename(newDirOrFileName: String, renameExisting: Boolean = false): Path {
            val options = buildSet<CopyOption> {
                if (renameExisting) add(StandardCopyOption.REPLACE_EXISTING)
            }
            return Files.move(this, parent.resolve(newDirOrFileName), *options.toTypedArray())
        }

        override fun editAccessCodeFromFile(log: Logger?) : String? {
            return editAccessCodeFilePath.takeIf { file -> file.exists().also { if (!it) log?.error("`$file` does not exist") } }?.readText()?.trim()
        }

        override fun editAccessCodeToFile(editAccessCode: String) {
            editAccessCodeFilePath.writeText(editAccessCode)
        }

        fun Path.deleteDirectory()  {
            /**
             * PRB: [deleteExisting] throws DirectoryNotEmptyException if the directory exists but is not empty.
             * WO:
             * [Delete a Directory Recursively in Java](https://www.baeldung.com/java-delete-directory)
             * [4. Using FileSystemUtils from Spring](https://www.baeldung.com/java-delete-directory#spring)
             */
            FileSystemUtils.deleteRecursively(this)
        }

        fun Path.deleteFile()  {
            deleteExisting()
        }

    }


}